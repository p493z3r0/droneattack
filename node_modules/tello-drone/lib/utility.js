"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatCommand = exports.parseDroneState = exports.verifyCommand = void 0;
const assert_1 = __importDefault(require("assert"));
const tello_data_json_1 = require("./data/tello-data.json");
const limits = Object.keys(tello_data_json_1.commandLimits);
const commands = [...tello_data_json_1.validCommands.control, ...tello_data_json_1.validCommands.read, ...tello_data_json_1.validCommands.set];
function verifyCommand(command, options) {
    assert_1.default.strictEqual(typeof command, "string");
    const givenOptions = options || {};
    const currentCommandLimits = tello_data_json_1.commandLimits[command] || {};
    if (!commands.includes(command)) {
        return new Error(`invalid command: '${command}'`);
    }
    const commandRequiresOptions = limits.includes(command);
    const hasGivenOptions = !!Object.keys(givenOptions).length;
    if (!hasGivenOptions) {
        if (limits.includes(command)) {
            return new Error(`Expected an option object along with the command: '${command}'`);
        }
    }
    if (commandRequiresOptions) {
        const allRequiredOptions = Object.keys(currentCommandLimits);
        const givenOptionKeys = Object.keys(givenOptions);
        // Check if we are missing any options
        for (const option of allRequiredOptions) {
            if (!givenOptionKeys.includes(option)) {
                return new Error(`expected '${option}' in options but recieved undefined`);
            }
        }
    }
    if (hasGivenOptions) {
        const allRequiredOptions = Object.keys(currentCommandLimits);
        const givenOptionKeys = Object.keys(givenOptions);
        const commandValueIsEnum = Array.isArray(currentCommandLimits);
        // Check if we have any extra options that dont belong
        for (const option of givenOptionKeys) {
            if (!allRequiredOptions.includes(option)) {
                return new Error(`unexpected '${option}' in options`);
            }
        }
        for (const [key, value] of Object.entries(givenOptions)) {
            const optionsLimits = currentCommandLimits[key];
            const optionLimitKeys = Object.keys(optionsLimits);
            const hasMinMax = optionLimitKeys.includes("min") || optionLimitKeys.includes("max");
            // If we dont have an array (enum) or a min max property, something is not right
            if (optionsLimits === undefined) {
                return new Error(`Unexpected error with following parameters: ${[command, key, `[${Object.entries(givenOptions)}]`]}, no option limits found`);
            }
            // Check if value is within min and max value
            if (hasMinMax) {
                const { max } = optionsLimits;
                const { min } = optionsLimits;
                const hasExceeded = typeof max === "number" && value > max;
                const hasDeceed = typeof max === "number" && value < min;
                if (hasExceeded || hasDeceed) {
                    return new Error(`invalid value ${key}: ${value}, expected ${key} to range between ${min}, ${max}`);
                }
            }
            // Check if the value is one of the enum
            if (commandValueIsEnum && !optionsLimits.includes(value)) {
                return new Error(`invalid value ${key}: ${value} expected [${currentCommandLimits.toString()}]`);
            }
        }
    }
}
exports.verifyCommand = verifyCommand;
function parseDroneState(state) {
    const stringState = Buffer.isBuffer(state) ? state.toString() : state;
    const reducer = (finalDataObject, nextDataPoint) => {
        if (!nextDataPoint.includes(":")) {
            return finalDataObject;
        }
        const [key, value] = nextDataPoint.split(":");
        let formattedValue;
        const isCommaSeperated = value.includes(",");
        if (isCommaSeperated) {
            formattedValue = value.split(",").map(val => (Number.isNaN(parseFloat(val)) ? val : parseFloat(val)));
        }
        else {
            formattedValue = Number.isNaN(parseFloat(value)) ? value : parseFloat(value);
        }
        return Object.assign(Object.assign({}, finalDataObject), { [key]: formattedValue === undefined ? value : formattedValue });
    };
    return stringState.split(";").reduce(reducer, {});
}
exports.parseDroneState = parseDroneState;
function formatCommand(command, options) {
    let formattedCommand = command;
    for (const value of Object.values(options)) {
        formattedCommand += ` ${value}`;
    }
    return formattedCommand;
}
exports.formatCommand = formatCommand;
