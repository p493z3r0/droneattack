"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Commander = void 0;
const events_1 = require("events");
const dgram_1 = require("dgram");
const Command_1 = require("./Command");
const Response_1 = require("./Response");
const CommanderEvent_1 = require("./enums/CommanderEvent");
const ControlCommand_1 = require("./enums/ControlCommand");
/**
 *
 */
class Commander extends events_1.EventEmitter {
    /**
     *
     */
    constructor(options) {
        super();
        const defaults = {
            localAddress: '0.0.0.0',
            localPort: 8889,
            remoteAddress: '192.168.1.10',
            remotePort: 8889
        };
        const localOptions = {
            ...defaults,
            ...options
        };
        this._localAddress = localOptions.localAddress;
        this._localPort = localOptions.localPort;
        this._remoteAddress = localOptions.remoteAddress;
        this._remotePort = localOptions.remotePort;
        this._initialised = false;
        this._socketBound = false;
        this._socket = dgram_1.createSocket('udp4');
    }
    /**
     *
     */
    async initialise() {
        this._bindSocket();
        await this._sendCommand(ControlCommand_1.ControlCommandEnum.command);
        this._initialised = true;
    }
    async destroy() {
        this._socket.close();
        this._socket.removeAllListeners();
    }
    /**
     *
     * @param command
     * @param params
     */
    async control(command, params) {
        const response = await this._sendCommand(command, params);
        return response.success;
    }
    /**
     *
     * @param command
     * @param params
     */
    async set(command, params) {
        const response = await this._sendCommand(command, params);
        return response.success;
    }
    /**
     *
     * @param command
     * @param params
     */
    async read(command, params) {
        const response = await this._sendCommand(command, params, { readCommand: true });
        return response.value;
    }
    /**
     *
     * @param commandType
     * @param params
     * @param options
     */
    async _sendCommand(commandType, params, options) {
        const localOptions = {
            readCommand: false,
            timeout: 2000,
            ...options
        };
        // Move to queue
        const command = new Command_1.Command(commandType, params, localOptions.readCommand);
        return new Promise((resolve, reject) => {
            this._socket.send(command.toString(), this._remotePort, this._remoteAddress, (err) => {
                if (err) {
                    return reject(err);
                }
                console.log(`>> ${command.toString()}`);
            });
            // const timeout = setInterval(() => {
            //   return reject(new Error(`Command timed out: ${ command.toString() }...`));
            // }, localOptions.timeout);
            this._socket.once('message', (messageData) => {
                // clearInterval(timeout);
                console.log(`<< ${messageData.toString()}`);
                const response = new Response_1.Response(messageData);
                if (response.success === false) {
                    return reject(new Error(`Tello Error: ${response.error}`));
                }
                resolve(response);
            });
        });
    }
    /**
     *
     * @private
     */
    _bindSocket() {
        this._socket.on('error', (err) => {
            this.emit(CommanderEvent_1.CommanderEventEnum.error, err);
            this._socket.close();
        });
        this._socket.on('close', () => {
            this._socket.close();
        });
        this._socket.on('listening', () => {
            const address = this._socket.address();
            console.log(`server listening ${address.address}:${address.port}`);
        });
        this._socket.bind(this._localPort, this._localAddress);
        this._socketBound = true;
    }
    /**
     *
     */
    get localAddress() { return this._localAddress; }
    get localPort() { return this._localPort; }
    get remoteAddress() { return this._remoteAddress; }
    get remotePort() { return this._remotePort; }
    get initialised() { return this._initialised; }
}
exports.Commander = Commander;
//# sourceMappingURL=Commander.js.map